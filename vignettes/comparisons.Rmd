---
title: "Comparisons with other packages"
output: rmarkdown::html_vignette
bibliography: "`r system.file('references.bib', package='graphicalMCP')`"
vignette: >
  %\VignetteIndexEntry{Comparisons with other packages}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, message = FALSE, warning = FALSE}
library(graphicalMCP)
library(lrstat)
library(gMCP)
```

# Introduction

There are two R packages that cover graphical multiple comparison procedures (MCPs): `gMCP` [@rohmeyer-2020-gmcp] and `lrstat` [@lu-2023-lrstat]. The development of `graphicalMCP` benefited from these two packages. Here we provide some comparisons between `graphicalMCP` and other packages with respect to key functions.

# List of comparisons

- Weighting strategy for the closure
  - `graphicalMCP::graph_generate_weights`
  - `gMCP::generateWeights`
- Sequentially rejective procedures based on Bonferroni tests
  - `graphical::graph_test_shortcut`
  - `gMCP::gMCP`
- Power simulation for sequentially rejective procedures
  - `graphicalMCP::graph_calculate_power`
  - `gMCP::calcPower`
- Closed procedures with parametric tests
  - `graphicalMCP::graph_test_closure`
  - `gMCP::gMCP`
- Power simulation for closed procedures with parametric tests
  - `graphicalMCP::graph_calculate_power`
  - `gMCP::calcPower`
- Closed procedures with Simes tests
  - `graphicalMCP::graph_test_closure`
  - `gMCP::gMCP`
- Power simulation for closed procedures with Simes tests
  - `graphicalMCP::graph_calculate_power`
  - `gMCP::calcPower`

# Comparisons of weighting strategies

A random graph for five hypotheses will be generated and used for the comparison. Weighting strategies from the following two functions will be compared: `graphicalMCP::graph_generate_weights` and `gMCP::generateWeights`. This process is repeated 1000 times. Weighting strategies are matched for all 1000 cases.

```{r generate-weights}
set.seed(1234)
identical <- NULL
for (i in 1:1000) {
  graph <- random_graph(5)
  graphicalmcp_weights <- graphicalMCP::graph_generate_weights(graph)
  dimnames(graphicalmcp_weights) <- list(NULL, NULL)
  gmcp_weights <- 
    gMCP::generateWeights(graph$transitions, graph$hypotheses)
  gmcp_weights <- gmcp_weights[nrow(gmcp_weights):1, ] # Reorder rows
  identical <- c(identical, all.equal(gmcp_weights, graphicalmcp_weights))
}
all(identical)
```

# Comparisons of sequentially rejective procedures based on Bonferroni tests

## Adjusted p-values for testing
A random graph for five hypotheses will be generated and used for the comparison. A set of p-values is randomly generated to be used for the graphical MCP. Adjusted p-values are calculated and compared using the following functions: `graphical::graph_test_shortcut` and `gMCP::gMCP`. This process is repeated 1000 times. Adjusted p-values are matched for all 1000 cases.

```{r shortcut}
set.seed(1234)
alpha <- 0.025
identical <- NULL
for (i in 1:1000) {
  graph <- random_graph(5)
  p <- runif(5, 0, alpha)
  graphicalmcp_test_shortcut <- 
    graph_test_shortcut(graph, p, alpha = alpha)$outputs$adjusted_p
  gmcp_test_shortcut <- 
    gMCP(as_graphMCP(graph), p, alpha = alpha)@adjPValues
  identical <- c(
    identical, 
    all.equal(graphicalmcp_test_shortcut, gmcp_test_shortcut)
  )
}
all(identical)
```

## Power simulations

A random graph for five hypotheses will be generated and used for the comparison. A set of marginal power is randomly generated 1000 times. Since different simulation methods are used, results are slightly different. The maximum absolute difference in local power is 0.0051 (0.51%) among 1000 cases, which is relatively small.

```{r power-shortcut, eval = FALSE}
set.seed(1234)
alpha <- 0.025
graphicalmcp_power <- NULL
gmcp_power <- NULL
for (i in 1:1000) {
  graph <- random_graph(5)
  marginal_power <- runif(5, 0.5, 0.9)
  noncentrality_parameter <-
  qnorm(1 - 0.025, lower.tail = TRUE) -
  qnorm(1 - marginal_power, lower.tail = TRUE)
  sim_corr <- matrix(.5, 5, 5)
  diag(sim_corr) <- 1
  
  set.seed(1234 + i - 1)
  graphicalmcp_power <- rbind(
    graphicalmcp_power,
    graph_calculate_power(
      graph,
      alpha = alpha,
      power_marginal = marginal_power,
      sim_corr = sim_corr,
      sim_n = 2^17
    )$power$power_local
  )
  
  set.seed(1234 + i - 1)
  gmcp_power <- rbind(
    gmcp_power,
    calcPower(
      graph$hypotheses,
      alpha = alpha,
      graph$transitions,
      mean = noncentrality_parameter,
      corr.sim = sim_corr,
      n.sim = 2^17
    )$LocalPower
  )
}

diff <- data.frame(
  rbind(graphicalmcp_power, gmcp_power),
  procedure = rep(c("graphicalMCP", "gMCP"), each = nrow(graphicalmcp_power))
)
  
write.csv(
  diff,
  here::here("vignettes/cache/comparisons_power_shortcut.csv"),
  row.names = FALSE
)

diff <- read.csv(here::here("vignettes/cache/comparisons_power_shortcut.csv"))
graphicalmcp_power <- subset(diff, procedure == "graphicalMCP")
gmcp_power <- subset(diff, procedure == "gMCP")
round(
  max(
    abs(
      graphicalmcp_power[, - ncol(graphicalmcp_power)] - 
        gmcp_power[, - ncol(gmcp_power)]
      )
    ),
  4
) # Maximum difference in local power among 1000 random graphs
```

# Comparisons of closed test procedures with parametric tests

## Adjusted p-values for testing
A successive graph with two primary and two secondary hypotheses will be generated and used for the comparison. A set of p-values is randomly generated to be used for the graphical MCP. Adjusted p-values are calculated and compared using the following functions: `graphical::graph_test_shortcut` and `gMCP::gMCP`. This process is repeated 1000 times. Adjusted p-values are matched for all 1000 cases.

```{r parametric}
hypotheses <- c(.5, .5, 0, 0)
transitions <- rbind(
  c(0, .5, .5, 0),
  c(.5, 0, 0, .5),
  c(0, 1, 0, 0),
  c(1, 0, 0, 0)
)

graph <- graph_create(hypotheses, transitions)

plot(ss_graph, vertex.size = 60)
set.seed(1234)
alpha <- 0.025
identical <- NULL
for (i in 1:1000) {
  graph <- random_graph(5)
  p <- runif(5, 0, alpha)
  graphicalmcp_test_shortcut <- 
    graph_test_shortcut(graph, p, alpha = alpha)$outputs$adjusted_p
  gmcp_test_shortcut <- 
    gMCP(as_graphMCP(graph), p, alpha = alpha)@adjPValues
  identical <- c(
    identical, 
    all.equal(graphicalmcp_test_shortcut, gmcp_test_shortcut)
  )
}
all(identical)
```

## Power simulations

A random graph for five hypotheses will be generated and used for the comparison. A set of marginal 100 times. Since different simulation methods are used, results are slightly different. The maximum absolute difference in local power is 0.0038 (0.38%) among 50 cases, which is small.

```{r power-parametric, eval = FALSE}
set.seed(1234)
alpha <- 0.025
graphicalmcp_power <- NULL
gmcp_power <- NULL
for (i in 1:1000) {
  graph <- random_graph(5)
  marginal_power <- runif(5, 0.5, 0.9)
  noncentrality_parameter <-
  qnorm(1 - 0.025, lower.tail = TRUE) -
  qnorm(1 - marginal_power, lower.tail = TRUE)
  sim_corr <- matrix(.5, 5, 5)
  diag(sim_corr) <- 1
  
  set.seed(1234 + i - 1)
  graphicalmcp_power <- rbind(
    graphicalmcp_power,
    graph_calculate_power(
      graph,
      alpha = alpha,
      power_marginal = marginal_power,
      sim_corr = sim_corr,
      sim_n = 2^17
    )$power$power_local
  )
  
  set.seed(1234 + i - 1)
  gmcp_power <- rbind(
    gmcp_power,
    calcPower(
      graph$hypotheses,
      alpha = alpha,
      graph$transitions,
      mean = noncentrality_parameter,
      corr.sim = sim_corr,
      n.sim = 2^17
    )$LocalPower
  )
}

diff <- data.frame(
  rbind(graphicalmcp_power, gmcp_power),
  procedure = rep(c("graphicalMCP", "gMCP"), each = nrow(graphicalmcp_power))
)
  
write.csv(
  diff,
  here::here("vignettes/cache/comparisons_power_shortcut.csv"),
  row.names = FALSE
)

diff <- read.csv(here::here("vignettes/cache/comparisons_power_shortcut.csv"))
graphicalmcp_power <- subset(diff, procedure == "graphicalMCP")
gmcp_power <- subset(diff, procedure == "gMCP")
round(
  max(
    abs(
      graphicalmcp_power[, - ncol(graphicalmcp_power)] - 
        gmcp_power[, - gmcp_power]
      )
    ), 4
) # Maximum difference in local power among 1000 random graphs
```

## gMCP

gMCP is the pioneer R package for graphical MCPs, and it covers many common use cases. We'll compare it to graphicalMCP for generating the weights of the closure, testing with Bonferroni and parametric testing, and power calculations using Bonferroni testing.

### Generate weights

Weights of the closure are identical, besides a different order and different names.

```{r gen-wgt-gmcp}
graphicalmcp_weights <- graph_generate_weights(ss_graph)
dimnames(graphicalmcp_weights) <- list(NULL, NULL)

gmcp_weights <- generateWeights(ss_graph$transitions, ss_graph$hypotheses)

all.equal(gmcp_weights, graphicalmcp_weights[15:1, ])
```

### Bonferroni adjusted p-values

```{r test-bonf}
p <- c(.001, .019, .01, .05)

graphicalmcp_test_bonf <- graph_test_shortcut(ss_graph, p)

gmcp_test_bonf <- gMCP(as_graphMCP(ss_graph), p, alpha = .025)

all.equal(graphicalmcp_test_bonf$outputs$adjusted_p, gmcp_test_bonf@adjPValues)
```

### Parametric adjusted p-values

Parametric adjusted p-values are calculated at different precision between packages.

```{r test-para}
test_corr <- rbind(
  c(1, .5, NA, NA),
  c(.5, 1, NA, NA),
  c(NA, NA, 1, NA),
  c(NA, NA, NA, 1)
)

graphicalmcp_test_para <-
  graph_test_closure(
    ss_graph,
    p,
    test_groups = list(1:2, 3:4),
    test_types = c("p", "b"),
    test_corr = list(test_corr[1:2, 1:2], NA)
  )

gmcp_test_para <-
  gMCP(
    as_graphMCP(ss_graph),
    p,
    alpha = .025,
    correlation = test_corr
  )

all.equal(
  round(graphicalmcp_test_para$outputs$adjusted_p, 10),
  round(gmcp_test_para@adjPValues, 10)
)
```

### Bonferroni power

The packages use slightly different simulation methods, which leads to slight differences in power.

```{r power-bonf}
marginal_power <- c(.8, .8, .7, .7)

noncentrality_parameter <-
  qnorm(1 - .025, lower.tail = TRUE) -
  qnorm(1 - marginal_power, lower.tail = TRUE)

sim_corr <- matrix(.5, 4, 4)
diag(sim_corr) <- 1

set.seed(92123)
graphicalmcp_power <-
  graph_calculate_power(
    ss_graph,
    power_marginal = marginal_power,
    sim_corr = sim_corr,
    sim_n = 2^17
  )

set.seed(92123)
gmcp_power <-
  calcPower(
    ss_graph$hypotheses,
    .025,
    ss_graph$transitions,
    mean = noncentrality_parameter,
    corr.sim = sim_corr,
    n.sim = 2^17
  )

print("Power differences")
structure(
  lapply(
    seq_along(gmcp_power),
    function(index) gmcp_power[[index]] - graphicalmcp_power$power[[index]]
  ),
  names = names(graphicalmcp_power$power)[1:4]
)
```

### Parametric power

```{r power-para}
set.seed(92123)
graphicalmcp_power_para <-
  graph_calculate_power(
    ss_graph,
    test_groups = list(1:2, 3:4),
    test_types = c("p", "b"),
    test_corr = list(test_corr[1:2, 1:2], NA),
    power_marginal = marginal_power,
    sim_corr = sim_corr,
    sim_n = 2^13
  )

set.seed(92123)
gmcp_power_para <-
  calcPower(
    ss_graph$hypotheses,
    .025,
    ss_graph$transitions,
    corr.test = test_corr,
    mean = noncentrality_parameter,
    corr.sim = sim_corr,
    n.sim = 2^13
  )

print("Power differences")
structure(
  lapply(
    seq_along(gmcp_power_para),
    function(index) {
      gmcp_power_para[[index]] - graphicalmcp_power_para$power[[index]]
    }
  ),
  names = names(graphicalmcp_power_para$power)[1:4]
)
```

## lrstat

lrstat is not primarily focused on graphical MCPs, but it does include functions to generate weights and run Simes testing, which makes it a good validation complement to gMCP.

### Generate weights

```{r gen-wgt-lrstat}
graphicalmcp_weights <- graph_generate_weights(ss_graph)

lrstat_weights <- fwgtmat(ss_graph$hypotheses, ss_graph$transitions)

all.equal(lrstat_weights, unname(graphicalmcp_weights[, 5:8]))
```

### Simes adjusted p-values

```{r test-simes}
graphicalmcp_test_simes <-
  graph_test_closure(
    ss_graph,
    p,
    test_groups = list(1:2, 3:4),
    test_types = c("s", "b")
  )

family <- rbind(
  c(1, 1, 0, 0),
  c(0, 0, 1, 0),
  c(0, 0, 0, 1)
)

lrstat_test_simes <-
  fadjpsim(
    fwgtmat(ss_graph$hypotheses, ss_graph$transitions),
    p,
    family
  )

all.equal(
  unname(graphicalmcp_test_simes$outputs$adjusted_p),
  lrstat_test_simes
)
```

### Simes power

lrstat doesn't have a built-in MCP power function, but it can calculate many adjusted p-values quickly if given a matrix of p-values. Here we simulate p-values the same way as `graph_calculate_power()` and demonstrate that results are the same.

```{r power-simes}
set.seed(92123)
graphicalmcp_power_simes <-
  graph_calculate_power(
    ss_graph,
    power_marginal = marginal_power,
    test_groups = list(1:2, 3:4),
    test_types = c("s", "b"),
    sim_corr = sim_corr,
    sim_n = 1e5
  )

noncentrality_parameter <-
  qnorm(1 - .025, lower.tail = TRUE) -
  qnorm(1 - marginal_power, lower.tail = TRUE)

# Simulate p-values the same way as graph_calculate_power()
set.seed(92123)
p_sim <- pnorm(
  mvtnorm::rmvnorm(
    1e5,
    noncentrality_parameter,
    sigma = sim_corr
  ),
  lower.tail = FALSE
)

lrstat_p_adj_simes <-
  fadjpsim(
    fwgtmat(ss_graph$hypotheses, ss_graph$transitions),
    p_sim,
    family
  )

lrstat_power_simes <- colSums(lrstat_p_adj_simes <= .025) / 1e5

all.equal(
  lrstat_power_simes,
  unname(graphicalmcp_power_simes$power$power_local)
)
```
