% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/power_tests.R
\name{test_graph_fast}
\alias{test_graph_fast}
\title{Test a graph efficiently}
\usage{
test_graph_fast(
  graph,
  p,
  alpha = 0.05,
  groups = list(seq_along(graph$hypotheses)),
  test_types = c("bonferroni"),
  corr = NULL,
  intersections = generate_weights(graph),
  graph_size = length(graph$hypotheses),
  gw_size = 2^graph_size - 1,
  num_groups = length(groups)
)
}
\arguments{
\item{graph}{An initial graph as returned by \code{create_graph()}}

\item{p}{A numeric vector of p-values}

\item{alpha}{A numeric scalar specifying the global level to test at}

\item{groups}{A list of numeric vectors specifying hypotheses to test
together}

\item{test_types}{A character vector of tests to apply to the given groups}

\item{corr}{Optional if no \code{test_types} are parametric. A numeric matrix of
correlations between hypotheses' test statistics}

\item{intersections}{A numeric matrix of h-vectors and weights as created by
\code{generate_weights()}. For \code{test_graph_fast_v()} and
\code{test_graph_fast_vms()}, the compact representation of the same}

\item{graph_size}{Number of hypotheses in \code{graph}}

\item{gw_size}{Number of rows in \code{intersections}}

\item{num_groups}{Number of groups in \code{groups}}

\item{inter_list}{A list of intersection weights with critical values, as
created by \code{add_critical()}}
}
\value{
A logical vector of results indicating whether each hypothesis can be
accepted or rejected globally
}
\description{
For insight and nice reporting, prefer \code{test_graph()} with all of its
options. It is reasonably fast for interactive use. However in order to
minimize power run time, more efficient testing functions have been written.
The power simulation can be segmented so that certain parts, like generating
weights and calculating critical values, can be done only a single time. The
actual testing function can also be stripped down to just a few vectorized
lines for efficiency
}
\examples{
par_gate <- simple_successive_1()
graph_size <- length(par_gate$hypotheses)

p <- c(.001, .02, .002, .03)

weights <- generate_weights(par_gate)
compact_weights <- ifelse(
  weights[, seq_len(graph_size), drop = FALSE],
  weights[, seq_len(graph_size) + graph_size, drop = FALSE],
  NA
)

test_graph_fast_vms(p, .025, compact_weights)
}
