<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="graphicalMCP">
<title>Rationales to generate the closure and the weighting strategy of a graph • graphicalMCP</title>
<!-- favicons --><link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png">
<link rel="apple-touch-icon" type="image/png" sizes="180x180" href="../apple-touch-icon.png">
<link rel="apple-touch-icon" type="image/png" sizes="120x120" href="../apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" type="image/png" sizes="76x76" href="../apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" type="image/png" sizes="60x60" href="../apple-touch-icon-60x60.png">
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.2.2/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.2.2/bootstrap.bundle.min.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- bootstrap-toc --><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@v1.0.1/dist/bootstrap-toc.min.js" integrity="sha256-4veVQbu7//Lk5TSmc7YV48MxtMy98e26cf5MrgZYnwo=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- search --><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Rationales to generate the closure and the weighting strategy of a graph">
<meta property="og:description" content="graphicalMCP">
<meta property="og:image" content="https://urban-sniffle-p11zlpj.pages.github.io/logo.png">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>
    

    <nav class="navbar fixed-top navbar-light navbar-expand-lg bg-light"><div class="container">
    
    <a class="navbar-brand me-2" href="../index.html">graphicalMCP</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.1.0</small>

    
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item">
  <a class="nav-link" href="../articles/graphicalMCP.html">Get started</a>
</li>
<li class="nav-item">
  <a class="nav-link" href="../articles/glossary.html">Glossary</a>
</li>
<li class="nav-item">
  <a class="nav-link" href="../reference/index.html">Function reference</a>
</li>
<li class="active nav-item dropdown">
  <a href="#" class="nav-link dropdown-toggle" data-bs-toggle="dropdown" role="button" aria-expanded="false" aria-haspopup="true" id="dropdown-articles">Articles</a>
  <div class="dropdown-menu" aria-labelledby="dropdown-articles">
    <a class="dropdown-item" href="../articles/shortcut-testing.html">Sequentially rejective graphical multiple comparison procedures based on Bonferroni tests</a>
    <a class="dropdown-item" href="../articles/closed-testing.html">Graphical multiple comparison procedures based on the closure principle</a>
    <a class="dropdown-item" href="../articles/graph-examples.html">Common multiple comparison procedures illustrated using graphicalMCP</a>
    <a class="dropdown-item" href="../articles/comparisons.html">Comparisons with other packages</a>
    <a class="dropdown-item" href="../articles/generate-closure.html">Rationales to generate the closure and the weighting strategy of a graph</a>
    <div class="dropdown-divider"></div>
    <a class="dropdown-item" href="../articles/index.html">More articles...</a>
  </div>
</li>
<li class="nav-item">
  <a class="nav-link" href="../news/index.html">Changelog</a>
</li>
      </ul>
<form class="form-inline my-2 my-lg-0" role="search">
        <input type="search" class="form-control me-sm-2" aria-label="Toggle navigation" name="search-input" data-search-index="../search.json" id="search-input" placeholder="Search for" autocomplete="off">
</form>

      <ul class="navbar-nav">
<li class="nav-item">
  <a class="external-link nav-link" href="https://github.com/Gilead-BioStats/graphicalMCP/" aria-label="github">
    <span class="fab fa fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>

    
  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="../logo.png" class="logo" alt=""><h1>Rationales to generate the closure and the weighting strategy of a graph</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/Gilead-BioStats/graphicalMCP/blob/HEAD/vignettes/generate-closure.Rmd" class="external-link"><code>vignettes/generate-closure.Rmd</code></a></small>
      <div class="d-none name"><code>generate-closure.Rmd</code></div>
    </div>

    
    
<div class="section level2">
<h2 id="motivating-example">Motivating example<a class="anchor" aria-label="anchor" href="#motivating-example"></a>
</h2>
</div>
<div class="section level2">
<h2 id="motivating-example-1">Motivating example<a class="anchor" aria-label="anchor" href="#motivating-example-1"></a>
</h2>
<p>Consider a simple successive graph with four hypotheses. It has two
primary hypotheses <span class="math inline">\(H_1\)</span> and <span class="math inline">\(H_2\)</span> and two secondary hypotheses <span class="math inline">\(H_3\)</span> and <span class="math inline">\(H_4\)</span>. Initially, hypothesis weights are
split equally between <span class="math inline">\(H_1\)</span> and <span class="math inline">\(H_2\)</span> with 0.5. Hypotheses <span class="math inline">\(H_3\)</span> and <span class="math inline">\(H_4\)</span> receive 0 hypothesis weights because
<span class="math inline">\(H_3 (H_4)\)</span> is tested only if <span class="math inline">\(H_1 (H_2)\)</span> is rejected. Thus there is an
edge from <span class="math inline">\(H_1 (H_2)\)</span> to <span class="math inline">\(H_3 (H_4)\)</span> with a transition weight of 1.
When both <span class="math inline">\(H_1\)</span> and <span class="math inline">\(H_3\)</span> are rejected, their hypothesis
weights are propagated to <span class="math inline">\(H_2\)</span>;
similarly, when both <span class="math inline">\(H_2\)</span> and <span class="math inline">\(H_4\)</span> are rejected, their hypothesis
weights are propagated to <span class="math inline">\(H_1\)</span>. Thus
there is an edge from <span class="math inline">\(H_3 (H_4)\)</span> to
<span class="math inline">\(H_2 (H_1)\)</span> with a transition weight
of 1. A graphical multiple comparison procedure is illustrated
below.</p>
<p><img src="generate-closure_files/figure-html/base-graph-1-1.png" width="288" style="display: block; margin: auto;"></p>
</div>
<div class="section level2">
<h2 id="generating-the-closure">Generating the closure<a class="anchor" aria-label="anchor" href="#generating-the-closure"></a>
</h2>
<p>The closure of this multiple comparison procedure is a collection of
intersection hypotheses <span class="math inline">\(H_1\cap H_2\cap
H_3\cap H_4\)</span>, <span class="math inline">\(H_1\cap H_2\cap
H_3\)</span>, <span class="math inline">\(H_1\cap H_2\cap H_4\)</span>,
<span class="math inline">\(H_1\cap H_3\cap H_4\)</span>, <span class="math inline">\(H_2\cap H_3\cap H_4\ \ldots, H_1, H_2,
H_3\)</span>, and <span class="math inline">\(H_4\)</span>. In other
words, these intersection hypotheses consist of intersections based on
all non-empty subsets of <span class="math inline">\(\{1, 2, 3,
4\}\)</span>, e.g., <span class="math inline">\(\{1, 2, 3\}\)</span>,
<span class="math inline">\(\{1, 2, 4\}\)</span>, <span class="math inline">\(\{1, 3, 4\}\)</span>, <span class="math inline">\(\{2, 3, 4\}\)</span>, <span class="math inline">\(\ldots\)</span>. Thus there are <span class="math inline">\(2^4-1\)</span> intersection hypotheses. An
equivalent way to generate all intersection hypotheses is to use a
binary representation. For example, the intersection hypothesis <span class="math inline">\(H_1\cap H_2\cap H_3\cap H_4\)</span> corresponds
to <span class="math inline">\((1, 1, 1, 1)\)</span> and <span class="math inline">\(H_1\cap H_2\cap H_3\)</span> corresponds to <span class="math inline">\((1, 1, 1, 0)\)</span>. Then the closure can be
indexed by the power set of <span class="math inline">\(\{1, 2, 3,
4\}\)</span> as below. In general, one can use
<code>rev(expand.grid(rep(list(1:0), m)))</code> to general the closure,
where <span class="math inline">\(m\)</span> is the number of
hypotheses.</p>
<pre><code><span><span class="co">#&gt;    H1 H2 H3 H4</span></span>
<span><span class="co">#&gt; 1   1  1  1  1</span></span>
<span><span class="co">#&gt; 2   1  1  1  0</span></span>
<span><span class="co">#&gt; 3   1  1  0  1</span></span>
<span><span class="co">#&gt; 4   1  1  0  0</span></span>
<span><span class="co">#&gt; 5   1  0  1  1</span></span>
<span><span class="co">#&gt; 6   1  0  1  0</span></span>
<span><span class="co">#&gt; 7   1  0  0  1</span></span>
<span><span class="co">#&gt; 8   1  0  0  0</span></span>
<span><span class="co">#&gt; 9   0  1  1  1</span></span>
<span><span class="co">#&gt; 10  0  1  1  0</span></span>
<span><span class="co">#&gt; 11  0  1  0  1</span></span>
<span><span class="co">#&gt; 12  0  1  0  0</span></span>
<span><span class="co">#&gt; 13  0  0  1  1</span></span>
<span><span class="co">#&gt; 14  0  0  1  0</span></span>
<span><span class="co">#&gt; 15  0  0  0  1</span></span></code></pre>
<div class="section level3">
<h3 id="calculating-the-weighting-strategy">Calculating the weighting strategy<a class="anchor" aria-label="anchor" href="#calculating-the-weighting-strategy"></a>
</h3>
<p>Given the closure, one can calculate the hypothesis weight associated
with every hypothesis in every intersection hypothesis using Algorithm 1
<span class="citation">(Bretz et al. 2011)</span>. The whole collection
of hypothesis weights is called a weighting strategy. For example,
hypothesis weights are <span class="math inline">\((0.5, 0.5, 0,
0)\)</span> for the intersection hypothesis <span class="math inline">\(H_1\cap H_2 \cap H_3\cap H_4\)</span>. Then
hypothesis weights for the intersection hypothesis <span class="math inline">\(H_1\cap H_2 \cap H_3\)</span> are <span class="math inline">\((0.5, 0.5, 0, 0)\)</span>, which can be calculated
by removing <span class="math inline">\(H_4\)</span> from the initial
graph and applying Algorithm 1 <span class="citation">(Bretz et al.
2011)</span>. The algorithm calculates hypothesis weights in a
step-by-step fashion. For example, for the intersection hypothesis <span class="math inline">\(H_1\cap H_2\)</span>, it can start from <span class="math inline">\(H_1\cap H_2 \cap H_3\cap H_4\)</span> and
calculates hypothesis weights for <span class="math inline">\(H_1\cap
H_2 \cap H_3\)</span> by removing <span class="math inline">\(H_4\)</span> and then calculates hypothesis
weights for <span class="math inline">\(H_1\cap H_2\)</span> by removing
<span class="math inline">\(H_3\)</span>; it can also start from <span class="math inline">\(H_1\cap H_2 \cap H_3\)</span> (assuming its
hypotheses weights are stored) and calculates hypothesis weights for
<span class="math inline">\(H_1\cap H_2\)</span> by removing <span class="math inline">\(H_3\)</span>. Therefore, there are two strategies
to calculate the weighting strategy.</p>
<pre><code><span><span class="co">#&gt;      H1   H2   H3   H4</span></span>
<span><span class="co">#&gt; 1  0.50 0.50 0.00 0.00</span></span>
<span><span class="co">#&gt; 2  0.50 0.50 0.00 0.00</span></span>
<span><span class="co">#&gt; 3  0.50 0.50 0.00 0.00</span></span>
<span><span class="co">#&gt; 4  0.50 0.50 0.00 0.00</span></span>
<span><span class="co">#&gt; 5  0.75 0.00 0.00 0.25</span></span>
<span><span class="co">#&gt; 6  1.00 0.00 0.00 0.00</span></span>
<span><span class="co">#&gt; 7  0.75 0.00 0.00 0.25</span></span>
<span><span class="co">#&gt; 8  1.00 0.00 0.00 0.00</span></span>
<span><span class="co">#&gt; 9  0.00 0.75 0.25 0.00</span></span>
<span><span class="co">#&gt; 10 0.00 0.75 0.25 0.00</span></span>
<span><span class="co">#&gt; 11 0.00 1.00 0.00 0.00</span></span>
<span><span class="co">#&gt; 12 0.00 1.00 0.00 0.00</span></span>
<span><span class="co">#&gt; 13 0.00 0.00 0.50 0.50</span></span>
<span><span class="co">#&gt; 14 0.00 0.00 1.00 0.00</span></span>
<span><span class="co">#&gt; 15 0.00 0.00 0.00 1.00</span></span></code></pre>
<div class="section level4">
<h4 id="approach-1-simple-approach">Approach 1: Simple approach<a class="anchor" aria-label="anchor" href="#approach-1-simple-approach"></a>
</h4>
<p>The first strategy utilizes the initial graph as the starting point
and calculates hypothesis weights for all other intersection hypotheses.
For example, to calculate hypothesis weights for <span class="math inline">\(H_1\cap H_2\)</span>, it will start with the
intersection hypothesis <span class="math inline">\(H_1\cap H_2 \cap
H_3\cap H_4\)</span> and sequentially remove <span class="math inline">\(H_4\)</span> and <span class="math inline">\(H_3\)</span> (or in the other order). This
approach is simple to implement since hypothesis weights for <span class="math inline">\(H_1\cap H_2 \cap H_3\cap H_4\)</span> are
determined by the initial graph and always available. This approach is
similar to the one implemented in the <code>gMCP</code> R package. The
drawback is that it does not use other information to reduce the number
of calculations. For example, it is possible that hypothesis weights for
<span class="math inline">\(H_1\cap H_2 \cap H_3\)</span> have been
calculated when calculating for <span class="math inline">\(H_1\cap
H_2\)</span>. Using the information from <span class="math inline">\(H_1\cap H_2 \cap H_3\)</span> would only need the
one-step calculation, compared to the two-step calculation using <span class="math inline">\(H_1\cap H_2 \cap H_3\cap H_4\)</span>.</p>
</div>
<div class="section level4">
<h4 id="approach-2-parent-child-approach">Approach 2: Parent-child approach<a class="anchor" aria-label="anchor" href="#approach-2-parent-child-approach"></a>
</h4>
<p>This approach tries to avoid the drawback of Approach 1 by saving
intermediate graphs. Then it only performs one-step calculation which
could save time. In general, an intersection hypothesis has a parent
intersection hypothesis, which involves all hypotheses involved in the
first intersection and has one extra hypothesis. For example, the second
row of <code>matrix_intersections</code> is <span class="math inline">\(H_1\cap H_2 \cap H_3\)</span> and its parent
intersection is <span class="math inline">\(H_1\cap H_2 \cap H_3\cap
H_4\)</span> in the first row; the third row of
<code>matrix_intersections</code> is <span class="math inline">\(H_1\cap
H_2 \cap H_4\)</span> and its parent intersection is <span class="math inline">\(H_1\cap H_2 \cap H_3\cap H_4\)</span> in the first
row. Thus we can identify the parent intersection hypothesis for each
row in <code>matrix_intersections</code> (except row 1) as the row
number 1, 1, 2, 1, 2, 3, 4, 1, 2, 3, 4, 5, 6, 7. Given this sequence of
parent hypotheses, it is simple to obtain hypothesis weights for an
intersection hypothesis based on its parent intersection hypothesis via
one-step calculation.</p>
<p>It is of interest to understand this pattern and obtain it
efficiently. First, between the bottom half (rows 9 - 15) and top half
(rows 1 - 7), each row’s parent in the bottom half is the corresponding
row in the top half, eight rows up, because the only difference is the
flipping of <span class="math inline">\(H_1\)</span> from 1 in the top
half to 0 in the bottom half. For example, row 15’s parent is in row 15
- 8 = 7. Using this observation, we can determine parent hypotheses for
rows from 9 to 15 as 1, 2, 3, 4, 5, 6, 7. A similar pattern can be
observed for rows from 5 to 8. Their parent hypotheses are in rows 1, 2,
3, 4, respectively, by flipping <span class="math inline">\(H_2\)</span>
from 1 to 0. For rows 3 - 4, their parent hypotheses are in rows 1, 2,
respectively, by flipping <span class="math inline">\(H_3\)</span> from
1 to 0. Lastly for row 2, its parent hypothesis is in row 1. The row
number of the parent hypothesis can be efficiently generated by running
<code>do.call(c, lapply(2^(seq_len(m) - 1), seq_len))[-2^m, ]</code>,
where <span class="math inline">\(m\)</span> is the number of
hypotheses.</p>
</div>
</div>
<div class="section level3">
<h3 id="comparing-different-approaches-to-calculating-weighting-strategies">Comparing different approaches to calculating weighting
strategies<a class="anchor" aria-label="anchor" href="#comparing-different-approaches-to-calculating-weighting-strategies"></a>
</h3>
<p>To benchmark against existing approaches to calculating weighting
strategies, we compare the following approaches:
<code><a href="https://rdrr.io/pkg/gMCP/man/generateWeights.html" class="external-link">gMCP::generateWeights()</a></code> <span class="citation">(Rohmeyer
and Klinglmueller 2020)</span>, <code><a href="https://rdrr.io/pkg/lrstat/man/fwgtmat.html" class="external-link">lrstat::fwgtmat()</a></code> <span class="citation">(Lu 2016)</span>, Approach 1 (graphicalMCP simple) and
Approach 2 (graphicalMCP parent-child). Random graphs are generated for
the numbers of hypotheses of 4, 8, 12, and 16. Computing time (in median
log-10 milliseconds) is plotted below. We can see that
<code><a href="https://rdrr.io/pkg/gMCP/man/generateWeights.html" class="external-link">gMCP::generateWeights()</a></code> is the slowest and
<code><a href="https://rdrr.io/pkg/lrstat/man/fwgtmat.html" class="external-link">lrstat::fwgtmat()</a></code> is the fastest. Approach 2 (graphicalMCP
parent-child) is faster than Approach 1 (graphicalMCP simple). Note that
<code><a href="https://rdrr.io/pkg/lrstat/man/fwgtmat.html" class="external-link">lrstat::fwgtmat()</a></code> implements the calculation using C++,
which is known to be faster than R. But it is less stable than other
approaches, e.g., giving errors more often than others. Given that the
computing time of R-based approaches is acceptable, adding Rcpp
dependency is not considered in <code>graphicalMCP</code>. For these
considerations, we implement Approach 2 in
<code><a href="../reference/graph_generate_weights.html">graphicalMCP::graph_generate_weights()</a></code>.</p>
<p><img src="img/gw-benchmarks-plot.png"></p>
</div>
</div>
<div class="section level2">
<h2 id="improving-power-simulations-using-parent-child-relationships">Improving power simulations using parent-child relationships<a class="anchor" aria-label="anchor" href="#improving-power-simulations-using-parent-child-relationships"></a>
</h2>
<div class="section level3">
<h3 id="conventional-approach-for-power-simulations">Conventional approach for power simulations<a class="anchor" aria-label="anchor" href="#conventional-approach-for-power-simulations"></a>
</h3>
<p>The conventional approach for power simulations is to repeat the
following process many times, e.g., 100,000 times.</p>
<ol style="list-style-type: decimal">
<li>Simulate a set of p-values</li>
<li>Run the graphical multiple comparison procedure to
<ul>
<li>Determine which hypothesis can be rejected</li>
<li>Remove the rejected hypothesis and update the graph</li>
<li>Repeat until no more hypotheses can be rejected</li>
</ul>
</li>
</ol>
<p>Note that the same step to update the graph may repeat in many
replications, whichmay be repetitive. For <span class="math inline">\(m\)</span> hypotheses, there are at most <span class="math inline">\(2^m-1\)</span> graphs depending on which
hypotheses are rejected. These graphs correspond to the closure and the
weighting strategy. Thus an idea to avoid redundant updating of graphs
is to utilize the weighting strategy.</p>
</div>
<div class="section level3">
<h3 id="power-simulations-using-parent-child-relationships">Power simulations using parent-child relationships<a class="anchor" aria-label="anchor" href="#power-simulations-using-parent-child-relationships"></a>
</h3>
<p>The key to allow this approach is to efficiently identify the row of
the weighting strategy, given which hypotheses are rejected. Remembering
the pattern we found for Approach 2, the bottom half (rows 9 - 15) of
<code>matrix_intersections</code> is the same as the top half (rows 1 -
7), except flipping <span class="math inline">\(H_1\)</span> from 1 to
0. This means that if <span class="math inline">\(H_1\)</span> has not
been rejected (1 for <span class="math inline">\(H_1\)</span> in
<code>matrix_intersections</code>), the row number of that index should
be in the top half. For example, assume that <span class="math inline">\(H_2\)</span> and <span class="math inline">\(H_4\)</span> have been rejected and the index in
<code>matrix_intersections</code> should be <span class="math inline">\((1, 0, 1, 0)\)</span>. Since <span class="math inline">\(H_1\)</span> is 1, the corresponding row should be
in the top half (rows 1- 7). But <span class="math inline">\(H_2\)</span> is 0 and thus the corresponding row
should be in the bottom half within the top half (rows 5 - 7). Since
<span class="math inline">\(H_3\)</span> is 1 and thus the corresponding
row should be in the top half (rows 5 - 6). But <span class="math inline">\(H_4\)</span> is 0 and thus the corresponding row
should be 6. A useful way to calculate the row number for an index of
XXXX is <code>2^m - sum(XXXX * 2^(m:1 - 1))</code>. For example for
XXXX=1010, its row number should be
<code>(1 - 1) * 8 + (1 - 0) * 4 + (1 - 1) * 2 + (1 - 0) * 1 + 1 = 16 - 10 = 6</code>.</p>
<p>With the above way of efficiently identifying rows of
<code>weighting_strategy</code>, power simulations could be implemented
as follows:</p>
<ol style="list-style-type: decimal">
<li>Obtain the weighting strategy (once for all simulations)</li>
<li>Simulate a set of p-values</li>
<li>Run the graphical multiple comparison procedure to
<ul>
<li>Determine which hypothesis can be rejected</li>
<li>Remove the rejected hypothesis and identify the row of the weighting
strategy</li>
<li>Repeat until no more hypotheses can be rejected</li>
</ul>
</li>
</ol>
<p>The small modification in Step 3b makes this approach much faster
than the conventional approach for power simulations.</p>
</div>
<div class="section level3">
<h3 id="comparing-different-approaches-to-power-simulations">Comparing different approaches to power simulations<a class="anchor" aria-label="anchor" href="#comparing-different-approaches-to-power-simulations"></a>
</h3>
<p>To benchmark against existing approaches to calculating weighting
strategies, we compare the following approaches:
<code><a href="https://rdrr.io/pkg/gMCP/man/calcPower.html" class="external-link">gMCP::calcPower()</a></code>, Approach 1 (graphicalMCP conventional),
and Approach 2 (graphicalMCP parent-child). Both Holm and fixed sequence
procedures are considered with the numbers of hypotheses of 4, 8, 12,
and 16. Computing time (in median log-10 seconds) is plotted below. We
can see that <code><a href="https://rdrr.io/pkg/gMCP/man/calcPower.html" class="external-link">gMCP::calcPower()</a></code> is the fastest and Approach
1 (graphicalMCP conventional) is the lowest. Note that
<code><a href="https://rdrr.io/pkg/gMCP/man/calcPower.html" class="external-link">gMCP::calcPower()</a></code> implements the simulation using C, which
is known to be faster than R but is not easy to extend to other
situations. Given that the computing time of Approach 2 (graphicalMCP
parent-child) is acceptable, we implement it in
<code><a href="../reference/graph_calculate_power.html">graphicalMCP::graph_calculate_power()</a></code>.</p>
<p><img src="img/power-benchmarks-plot.png"></p>
</div>
</div>
<div class="section level2">
<h2 class="unnumbered" id="reference">Reference<a class="anchor" aria-label="anchor" href="#reference"></a>
</h2>
<div id="refs" class="references csl-bib-body hanging-indent">
<div id="ref-bretz-2011-graphical" class="csl-entry">
Bretz, Frank, Martin Posch, Ekkehard Glimm, Florian Klinglmueller, Willi
Maurer, and Kornelius Rohmeyer. 2011. <span>“Graphical Approaches for
Multiple Comparison Procedures Using Weighted Bonferroni, Simes, or
Parametric Tests.”</span> <em>Biometrical Journal</em> 53 (6): 894–913.
<a href="https://onlinelibrary.wiley.com/doi/10.1002/bimj.201000239" class="external-link">https://onlinelibrary.wiley.com/doi/10.1002/bimj.201000239</a>.
</div>
<div id="ref-lu-2016-graphical" class="csl-entry">
Lu, Kaifeng. 2016. <span>“Graphical Approaches Using a Bonferroni
Mixture of Weighted Simes Tests.”</span> <em>Statistics in Medicine</em>
35 (22): 4041–55. <a href="https://onlinelibrary.wiley.com/doi/10.1002/sim.6985" class="external-link">https://onlinelibrary.wiley.com/doi/10.1002/sim.6985</a>.
</div>
<div id="ref-rohmeyer-2020-gmcp" class="csl-entry">
Rohmeyer, Kornelius, and Florian Klinglmueller. 2020. <span>“<span class="nocase">gMCP</span>: Graph Based Multiple Test
Procedures.”</span> <a href="https://cran.r-project.org/package=gMCP" class="external-link">https://cran.r-project.org/package=gMCP</a>.
</div>
</div>
</div>
  </main><aside class="col-md-3"><nav id="toc"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p></p>
<p>Developed by Dong Xi, Ethan Brockmann, Gilead Biostatistics.</p>
</div>

<div class="pkgdown-footer-right">
  <p></p>
<p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.7.</p>
</div>

    </footer>
</div>

  

  

  </body>
</html>
