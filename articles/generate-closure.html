<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Rationales to generate the closure and the weighting strategy of a graph • graphicalMCP</title>
<!-- favicons --><link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png">
<link rel="apple-touch-icon" type="image/png" sizes="180x180" href="../apple-touch-icon.png">
<link rel="apple-touch-icon" type="image/png" sizes="120x120" href="../apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" type="image/png" sizes="76x76" href="../apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" type="image/png" sizes="60x60" href="../apple-touch-icon-60x60.png">
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.4.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.4.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Rationales to generate the closure and the weighting strategy of a graph">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">graphicalMCP</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.2.4</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../articles/graphicalMCP.html">Get started</a></li>
<li class="nav-item"><a class="nav-link" href="../articles/glossary.html">Glossary</a></li>
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Function reference</a></li>
<li class="active nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles">
<li><a class="dropdown-item" href="../articles/shortcut-testing.html">Sequentially rejective graphical multiple comparison procedures based on Bonferroni tests</a></li>
    <li><a class="dropdown-item" href="../articles/closed-testing.html">Graphical multiple comparison procedures based on the closure principle</a></li>
    <li><a class="dropdown-item" href="../articles/graph-examples.html">Common multiple comparison procedures illustrated using graphicalMCP</a></li>
    <li><a class="dropdown-item" href="../articles/comparisons.html">Comparisons with other packages</a></li>
    <li><a class="dropdown-item" href="../articles/generate-closure.html">Rationales to generate the closure and the weighting strategy of a graph</a></li>
    <li><hr class="dropdown-divider"></li>
    <li><a class="dropdown-item" href="../articles/index.html">More articles...</a></li>
  </ul>
</li>
<li class="nav-item"><a class="nav-link" href="../news/index.html">Changelog</a></li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/Gilead-BioStats/graphicalMCP/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="../logo.png" class="logo" alt=""><h1>Rationales to generate the closure and the weighting strategy of a graph</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/Gilead-BioStats/graphicalMCP/blob/v0.2.4/vignettes/generate-closure.Rmd" class="external-link"><code>vignettes/generate-closure.Rmd</code></a></small>
      <div class="d-none name"><code>generate-closure.Rmd</code></div>
    </div>

    
    
<div class="section level2">
<h2 id="motivating-example">Motivating example<a class="anchor" aria-label="anchor" href="#motivating-example"></a>
</h2>
<p>Consider a simple successive graph with four hypotheses. It has two
primary hypotheses
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>H</mi><mn>1</mn></msub><annotation encoding="application/x-tex">H_1</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>H</mi><mn>2</mn></msub><annotation encoding="application/x-tex">H_2</annotation></semantics></math>
and two secondary hypotheses
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>H</mi><mn>3</mn></msub><annotation encoding="application/x-tex">H_3</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>H</mi><mn>4</mn></msub><annotation encoding="application/x-tex">H_4</annotation></semantics></math>.
Initially, hypothesis weights are split equally between
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>H</mi><mn>1</mn></msub><annotation encoding="application/x-tex">H_1</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>H</mi><mn>2</mn></msub><annotation encoding="application/x-tex">H_2</annotation></semantics></math>
with 0.5. Hypotheses
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>H</mi><mn>3</mn></msub><annotation encoding="application/x-tex">H_3</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>H</mi><mn>4</mn></msub><annotation encoding="application/x-tex">H_4</annotation></semantics></math>
receive 0 hypothesis weights because
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mn>3</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>H</mi><mn>4</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">H_3 (H_4)</annotation></semantics></math>
is tested only if
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mn>1</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>H</mi><mn>2</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">H_1 (H_2)</annotation></semantics></math>
is rejected. Thus there is an edge from
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mn>1</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>H</mi><mn>2</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">H_1 (H_2)</annotation></semantics></math>
to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mn>3</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>H</mi><mn>4</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">H_3 (H_4)</annotation></semantics></math>
with a transition weight of 1. When both
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>H</mi><mn>1</mn></msub><annotation encoding="application/x-tex">H_1</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>H</mi><mn>3</mn></msub><annotation encoding="application/x-tex">H_3</annotation></semantics></math>
are rejected, their hypothesis weights are propagated to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>H</mi><mn>2</mn></msub><annotation encoding="application/x-tex">H_2</annotation></semantics></math>;
similarly, when both
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>H</mi><mn>2</mn></msub><annotation encoding="application/x-tex">H_2</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>H</mi><mn>4</mn></msub><annotation encoding="application/x-tex">H_4</annotation></semantics></math>
are rejected, their hypothesis weights are propagated to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>H</mi><mn>1</mn></msub><annotation encoding="application/x-tex">H_1</annotation></semantics></math>.
Thus there is an edge from
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mn>3</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>H</mi><mn>4</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">H_3 (H_4)</annotation></semantics></math>
to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mn>2</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>H</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">H_2 (H_1)</annotation></semantics></math>
with a transition weight of 1. A graphical multiple comparison procedure
is illustrated below.</p>
<p><img src="generate-closure_files/figure-html/base-graph-1-1.png" width="288" style="display: block; margin: auto;"></p>
</div>
<div class="section level2">
<h2 id="generating-the-closure">Generating the closure<a class="anchor" aria-label="anchor" href="#generating-the-closure"></a>
</h2>
<p>The closure of this multiple comparison procedure is a collection of
intersection hypotheses
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mn>1</mn></msub><mo>∩</mo><msub><mi>H</mi><mn>2</mn></msub><mo>∩</mo><msub><mi>H</mi><mn>3</mn></msub><mo>∩</mo><msub><mi>H</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">H_1\cap H_2\cap H_3\cap H_4</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mn>1</mn></msub><mo>∩</mo><msub><mi>H</mi><mn>2</mn></msub><mo>∩</mo><msub><mi>H</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">H_1\cap H_2\cap H_3</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mn>1</mn></msub><mo>∩</mo><msub><mi>H</mi><mn>2</mn></msub><mo>∩</mo><msub><mi>H</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">H_1\cap H_2\cap H_4</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mn>1</mn></msub><mo>∩</mo><msub><mi>H</mi><mn>3</mn></msub><mo>∩</mo><msub><mi>H</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">H_1\cap H_3\cap H_4</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mn>2</mn></msub><mo>∩</mo><msub><mi>H</mi><mn>3</mn></msub><mo>∩</mo><msub><mi>H</mi><mn>4</mn></msub><mspace width="0.222em"></mspace><mi>…</mi><mo>,</mo><msub><mi>H</mi><mn>1</mn></msub><mo>,</mo><msub><mi>H</mi><mn>2</mn></msub><mo>,</mo><msub><mi>H</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">H_2\cap H_3\cap H_4\ \ldots, H_1, H_2, H_3</annotation></semantics></math>,
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>H</mi><mn>4</mn></msub><annotation encoding="application/x-tex">H_4</annotation></semantics></math>.
In other words, these intersection hypotheses consist of intersections
based on all non-empty subsets of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo>,</mo><mn>3</mn><mo>,</mo><mn>4</mn><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\{1, 2, 3, 4\}</annotation></semantics></math>,
e.g.,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo>,</mo><mn>3</mn><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\{1, 2, 3\}</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo>,</mo><mn>4</mn><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\{1, 2, 4\}</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><mn>1</mn><mo>,</mo><mn>3</mn><mo>,</mo><mn>4</mn><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\{1, 3, 4\}</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><mn>2</mn><mo>,</mo><mn>3</mn><mo>,</mo><mn>4</mn><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\{2, 3, 4\}</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>…</mi><annotation encoding="application/x-tex">\ldots</annotation></semantics></math>.
Thus there are
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>4</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^4-1</annotation></semantics></math>
intersection hypotheses. An equivalent way to generate all intersection
hypotheses is to use a binary representation. For example, the
intersection hypothesis
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mn>1</mn></msub><mo>∩</mo><msub><mi>H</mi><mn>2</mn></msub><mo>∩</mo><msub><mi>H</mi><mn>3</mn></msub><mo>∩</mo><msub><mi>H</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">H_1\cap H_2\cap H_3\cap H_4</annotation></semantics></math>
corresponds to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(1, 1, 1, 1)</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mn>1</mn></msub><mo>∩</mo><msub><mi>H</mi><mn>2</mn></msub><mo>∩</mo><msub><mi>H</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">H_1\cap H_2\cap H_3</annotation></semantics></math>
corresponds to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>0</mn><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(1, 1, 1, 0)</annotation></semantics></math>.
Then the closure can be indexed by the power set of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo>,</mo><mn>3</mn><mo>,</mo><mn>4</mn><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\{1, 2, 3, 4\}</annotation></semantics></math>
as below. In general, one can use
<code>rev(expand.grid(rep(list(1:0), m)))</code> to general the closure,
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>
is the number of hypotheses.</p>
<pre><code><span><span class="co">#&gt;    H1 H2 H3 H4</span></span>
<span><span class="co">#&gt; 1   1  1  1  1</span></span>
<span><span class="co">#&gt; 2   1  1  1  0</span></span>
<span><span class="co">#&gt; 3   1  1  0  1</span></span>
<span><span class="co">#&gt; 4   1  1  0  0</span></span>
<span><span class="co">#&gt; 5   1  0  1  1</span></span>
<span><span class="co">#&gt; 6   1  0  1  0</span></span>
<span><span class="co">#&gt; 7   1  0  0  1</span></span>
<span><span class="co">#&gt; 8   1  0  0  0</span></span>
<span><span class="co">#&gt; 9   0  1  1  1</span></span>
<span><span class="co">#&gt; 10  0  1  1  0</span></span>
<span><span class="co">#&gt; 11  0  1  0  1</span></span>
<span><span class="co">#&gt; 12  0  1  0  0</span></span>
<span><span class="co">#&gt; 13  0  0  1  1</span></span>
<span><span class="co">#&gt; 14  0  0  1  0</span></span>
<span><span class="co">#&gt; 15  0  0  0  1</span></span></code></pre>
<div class="section level3">
<h3 id="calculating-the-weighting-strategy">Calculating the weighting strategy<a class="anchor" aria-label="anchor" href="#calculating-the-weighting-strategy"></a>
</h3>
<p>Given the closure, one can calculate the hypothesis weight associated
with every hypothesis in every intersection hypothesis using Algorithm 1
<span class="citation">(Bretz et al. 2011)</span>. The whole collection
of hypothesis weights is called a weighting strategy. For example,
hypothesis weights are
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mn>0.5</mn><mo>,</mo><mn>0.5</mn><mo>,</mo><mn>0</mn><mo>,</mo><mn>0</mn><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(0.5, 0.5, 0, 0)</annotation></semantics></math>
for the intersection hypothesis
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mn>1</mn></msub><mo>∩</mo><msub><mi>H</mi><mn>2</mn></msub><mo>∩</mo><msub><mi>H</mi><mn>3</mn></msub><mo>∩</mo><msub><mi>H</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">H_1\cap H_2 \cap H_3\cap H_4</annotation></semantics></math>.
Then hypothesis weights for the intersection hypothesis
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mn>1</mn></msub><mo>∩</mo><msub><mi>H</mi><mn>2</mn></msub><mo>∩</mo><msub><mi>H</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">H_1\cap H_2 \cap H_3</annotation></semantics></math>
are
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mn>0.5</mn><mo>,</mo><mn>0.5</mn><mo>,</mo><mn>0</mn><mo>,</mo><mn>0</mn><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(0.5, 0.5, 0, 0)</annotation></semantics></math>,
which can be calculated by removing
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>H</mi><mn>4</mn></msub><annotation encoding="application/x-tex">H_4</annotation></semantics></math>
from the initial graph and applying Algorithm 1 <span class="citation">(Bretz et al. 2011)</span>. The algorithm calculates
hypothesis weights in a step-by-step fashion. For example, for the
intersection hypothesis
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mn>1</mn></msub><mo>∩</mo><msub><mi>H</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">H_1\cap H_2</annotation></semantics></math>,
it can start from
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mn>1</mn></msub><mo>∩</mo><msub><mi>H</mi><mn>2</mn></msub><mo>∩</mo><msub><mi>H</mi><mn>3</mn></msub><mo>∩</mo><msub><mi>H</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">H_1\cap H_2 \cap H_3\cap H_4</annotation></semantics></math>
and calculates hypothesis weights for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mn>1</mn></msub><mo>∩</mo><msub><mi>H</mi><mn>2</mn></msub><mo>∩</mo><msub><mi>H</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">H_1\cap H_2 \cap H_3</annotation></semantics></math>
by removing
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>H</mi><mn>4</mn></msub><annotation encoding="application/x-tex">H_4</annotation></semantics></math>
and then calculates hypothesis weights for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mn>1</mn></msub><mo>∩</mo><msub><mi>H</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">H_1\cap H_2</annotation></semantics></math>
by removing
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>H</mi><mn>3</mn></msub><annotation encoding="application/x-tex">H_3</annotation></semantics></math>;
it can also start from
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mn>1</mn></msub><mo>∩</mo><msub><mi>H</mi><mn>2</mn></msub><mo>∩</mo><msub><mi>H</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">H_1\cap H_2 \cap H_3</annotation></semantics></math>
(assuming its hypotheses weights are stored) and calculates hypothesis
weights for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mn>1</mn></msub><mo>∩</mo><msub><mi>H</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">H_1\cap H_2</annotation></semantics></math>
by removing
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>H</mi><mn>3</mn></msub><annotation encoding="application/x-tex">H_3</annotation></semantics></math>.
Therefore, there are two strategies to calculate the weighting
strategy.</p>
<pre><code><span><span class="co">#&gt;      H1   H2   H3   H4</span></span>
<span><span class="co">#&gt; 1  0.50 0.50 0.00 0.00</span></span>
<span><span class="co">#&gt; 2  0.50 0.50 0.00 0.00</span></span>
<span><span class="co">#&gt; 3  0.50 0.50 0.00 0.00</span></span>
<span><span class="co">#&gt; 4  0.50 0.50 0.00 0.00</span></span>
<span><span class="co">#&gt; 5  0.75 0.00 0.00 0.25</span></span>
<span><span class="co">#&gt; 6  1.00 0.00 0.00 0.00</span></span>
<span><span class="co">#&gt; 7  0.75 0.00 0.00 0.25</span></span>
<span><span class="co">#&gt; 8  1.00 0.00 0.00 0.00</span></span>
<span><span class="co">#&gt; 9  0.00 0.75 0.25 0.00</span></span>
<span><span class="co">#&gt; 10 0.00 0.75 0.25 0.00</span></span>
<span><span class="co">#&gt; 11 0.00 1.00 0.00 0.00</span></span>
<span><span class="co">#&gt; 12 0.00 1.00 0.00 0.00</span></span>
<span><span class="co">#&gt; 13 0.00 0.00 0.50 0.50</span></span>
<span><span class="co">#&gt; 14 0.00 0.00 1.00 0.00</span></span>
<span><span class="co">#&gt; 15 0.00 0.00 0.00 1.00</span></span></code></pre>
<div class="section level4">
<h4 id="approach-1-simple-approach">Approach 1: Simple approach<a class="anchor" aria-label="anchor" href="#approach-1-simple-approach"></a>
</h4>
<p>The first strategy utilizes the initial graph as the starting point
and calculates hypothesis weights for all other intersection hypotheses.
For example, to calculate hypothesis weights for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mn>1</mn></msub><mo>∩</mo><msub><mi>H</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">H_1\cap H_2</annotation></semantics></math>,
it will start with the intersection hypothesis
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mn>1</mn></msub><mo>∩</mo><msub><mi>H</mi><mn>2</mn></msub><mo>∩</mo><msub><mi>H</mi><mn>3</mn></msub><mo>∩</mo><msub><mi>H</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">H_1\cap H_2 \cap H_3\cap H_4</annotation></semantics></math>
and sequentially remove
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>H</mi><mn>4</mn></msub><annotation encoding="application/x-tex">H_4</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>H</mi><mn>3</mn></msub><annotation encoding="application/x-tex">H_3</annotation></semantics></math>
(or in the other order). This approach is simple to implement since
hypothesis weights for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mn>1</mn></msub><mo>∩</mo><msub><mi>H</mi><mn>2</mn></msub><mo>∩</mo><msub><mi>H</mi><mn>3</mn></msub><mo>∩</mo><msub><mi>H</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">H_1\cap H_2 \cap H_3\cap H_4</annotation></semantics></math>
are determined by the initial graph and always available. This approach
is similar to the one implemented in the <code>gMCP</code> R package.
The drawback is that it does not use other information to reduce the
number of calculations. For example, it is possible that hypothesis
weights for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mn>1</mn></msub><mo>∩</mo><msub><mi>H</mi><mn>2</mn></msub><mo>∩</mo><msub><mi>H</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">H_1\cap H_2 \cap H_3</annotation></semantics></math>
have been calculated when calculating for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mn>1</mn></msub><mo>∩</mo><msub><mi>H</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">H_1\cap H_2</annotation></semantics></math>.
Using the information from
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mn>1</mn></msub><mo>∩</mo><msub><mi>H</mi><mn>2</mn></msub><mo>∩</mo><msub><mi>H</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">H_1\cap H_2 \cap H_3</annotation></semantics></math>
would only need the one-step calculation, compared to the two-step
calculation using
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mn>1</mn></msub><mo>∩</mo><msub><mi>H</mi><mn>2</mn></msub><mo>∩</mo><msub><mi>H</mi><mn>3</mn></msub><mo>∩</mo><msub><mi>H</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">H_1\cap H_2 \cap H_3\cap H_4</annotation></semantics></math>.</p>
</div>
<div class="section level4">
<h4 id="approach-2-parent-child-approach">Approach 2: Parent-child approach<a class="anchor" aria-label="anchor" href="#approach-2-parent-child-approach"></a>
</h4>
<p>This approach tries to avoid the drawback of Approach 1 by saving
intermediate graphs. Then it only performs one-step calculation which
could save time. In general, an intersection hypothesis has a parent
intersection hypothesis, which involves all hypotheses involved in the
first intersection and has one extra hypothesis. For example, the second
row of <code>matrix_intersections</code> is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mn>1</mn></msub><mo>∩</mo><msub><mi>H</mi><mn>2</mn></msub><mo>∩</mo><msub><mi>H</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">H_1\cap H_2 \cap H_3</annotation></semantics></math>
and its parent intersection is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mn>1</mn></msub><mo>∩</mo><msub><mi>H</mi><mn>2</mn></msub><mo>∩</mo><msub><mi>H</mi><mn>3</mn></msub><mo>∩</mo><msub><mi>H</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">H_1\cap H_2 \cap H_3\cap H_4</annotation></semantics></math>
in the first row; the third row of <code>matrix_intersections</code> is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mn>1</mn></msub><mo>∩</mo><msub><mi>H</mi><mn>2</mn></msub><mo>∩</mo><msub><mi>H</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">H_1\cap H_2 \cap H_4</annotation></semantics></math>
and its parent intersection is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mn>1</mn></msub><mo>∩</mo><msub><mi>H</mi><mn>2</mn></msub><mo>∩</mo><msub><mi>H</mi><mn>3</mn></msub><mo>∩</mo><msub><mi>H</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">H_1\cap H_2 \cap H_3\cap H_4</annotation></semantics></math>
in the first row. Thus we can identify the parent intersection
hypothesis for each row in <code>matrix_intersections</code> (except row
1) as the row number 1, 1, 2, 1, 2, 3, 4, 1, 2, 3, 4, 5, 6, 7. Given
this sequence of parent hypotheses, it is simple to obtain hypothesis
weights for an intersection hypothesis based on its parent intersection
hypothesis via one-step calculation.</p>
<p>It is of interest to understand this pattern and obtain it
efficiently. First, between the bottom half (rows 9 - 15) and top half
(rows 1 - 7), each row’s parent in the bottom half is the corresponding
row in the top half, eight rows up, because the only difference is the
flipping of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>H</mi><mn>1</mn></msub><annotation encoding="application/x-tex">H_1</annotation></semantics></math>
from 1 in the top half to 0 in the bottom half. For example, row 15’s
parent is in row 15 - 8 = 7. Using this observation, we can determine
parent hypotheses for rows from 9 to 15 as 1, 2, 3, 4, 5, 6, 7. A
similar pattern can be observed for rows from 5 to 8. Their parent
hypotheses are in rows 1, 2, 3, 4, respectively, by flipping
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>H</mi><mn>2</mn></msub><annotation encoding="application/x-tex">H_2</annotation></semantics></math>
from 1 to 0. For rows 3 - 4, their parent hypotheses are in rows 1, 2,
respectively, by flipping
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>H</mi><mn>3</mn></msub><annotation encoding="application/x-tex">H_3</annotation></semantics></math>
from 1 to 0. Lastly for row 2, its parent hypothesis is in row 1. The
row number of the parent hypothesis can be efficiently generated by
running
<code>do.call(c, lapply(2^(seq_len(m) - 1), seq_len))[-2^m, ]</code>,
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>
is the number of hypotheses.</p>
</div>
</div>
<div class="section level3">
<h3 id="comparing-different-approaches-to-calculating-weighting-strategies">Comparing different approaches to calculating weighting
strategies<a class="anchor" aria-label="anchor" href="#comparing-different-approaches-to-calculating-weighting-strategies"></a>
</h3>
<p>To benchmark against existing approaches to calculating weighting
strategies, we compare the following approaches:
<code><a href="https://rdrr.io/pkg/gMCP/man/generateWeights.html" class="external-link">gMCP::generateWeights()</a></code> <span class="citation">(Rohmeyer
and Klinglmueller 2024)</span>, <code><a href="https://rdrr.io/pkg/lrstat/man/fwgtmat.html" class="external-link">lrstat::fwgtmat()</a></code> <span class="citation">(Lu 2016)</span>, Approach 1 (graphicalMCP simple) and
Approach 2 (graphicalMCP parent-child). Random graphs are generated for
the numbers of hypotheses of 4, 8, 12, and 16. Computing time (in median
log-10 milliseconds) is plotted below. We can see that
<code><a href="https://rdrr.io/pkg/gMCP/man/generateWeights.html" class="external-link">gMCP::generateWeights()</a></code> is the slowest and
<code><a href="https://rdrr.io/pkg/lrstat/man/fwgtmat.html" class="external-link">lrstat::fwgtmat()</a></code> is the fastest. Approach 2 (graphicalMCP
parent-child) is faster than Approach 1 (graphicalMCP simple). Note that
<code><a href="https://rdrr.io/pkg/lrstat/man/fwgtmat.html" class="external-link">lrstat::fwgtmat()</a></code> implements the calculation using C++,
which is known to be faster than R. But it is less stable than other
approaches, e.g., giving errors more often than others. Given that the
computing time of R-based approaches is acceptable, adding Rcpp
dependency is not considered in <code>graphicalMCP</code>. For these
considerations, we implement Approach 2 in
<code><a href="../reference/graph_generate_weights.html">graphicalMCP::graph_generate_weights()</a></code>.</p>
<p><img src="generate-closure_files/figure-html/plot-gw-benchmarks-1.png" width="768" style="display: block; margin: auto;"></p>
</div>
</div>
<div class="section level2">
<h2 id="improving-power-simulations-using-parent-child-relationships">Improving power simulations using parent-child relationships<a class="anchor" aria-label="anchor" href="#improving-power-simulations-using-parent-child-relationships"></a>
</h2>
<div class="section level3">
<h3 id="conventional-approach-for-power-simulations">Conventional approach for power simulations<a class="anchor" aria-label="anchor" href="#conventional-approach-for-power-simulations"></a>
</h3>
<p>The conventional approach for power simulations is to repeat the
following process many times, e.g., 100,000 times.</p>
<ol style="list-style-type: decimal">
<li>Simulate a set of p-values</li>
<li>Run the graphical multiple comparison procedure to
<ul>
<li>Determine which hypothesis can be rejected</li>
<li>Remove the rejected hypothesis and update the graph</li>
<li>Repeat until no more hypotheses can be rejected</li>
</ul>
</li>
</ol>
<p>Note that the same step to update the graph may repeat in many
replications, which may be repetitive. For
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>
hypotheses, there are at most
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>m</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^m-1</annotation></semantics></math>
graphs depending on which hypotheses are rejected. These graphs
correspond to the closure and the weighting strategy. Thus an idea to
avoid redundant updating of graphs is to utilize the weighting
strategy.</p>
</div>
<div class="section level3">
<h3 id="power-simulations-using-parent-child-relationships">Power simulations using parent-child relationships<a class="anchor" aria-label="anchor" href="#power-simulations-using-parent-child-relationships"></a>
</h3>
<p>The key to allow this approach is to efficiently identify the row of
the weighting strategy, given which hypotheses are rejected. Remembering
the pattern we found for Approach 2, the bottom half (rows 9 - 15) of
<code>matrix_intersections</code> is the same as the top half (rows 1 -
7), except flipping
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>H</mi><mn>1</mn></msub><annotation encoding="application/x-tex">H_1</annotation></semantics></math>
from 1 to 0. This means that if
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>H</mi><mn>1</mn></msub><annotation encoding="application/x-tex">H_1</annotation></semantics></math>
has not been rejected (1 for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>H</mi><mn>1</mn></msub><annotation encoding="application/x-tex">H_1</annotation></semantics></math>
in <code>matrix_intersections</code>), the row number of that index
should be in the top half. For example, assume that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>H</mi><mn>2</mn></msub><annotation encoding="application/x-tex">H_2</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>H</mi><mn>4</mn></msub><annotation encoding="application/x-tex">H_4</annotation></semantics></math>
have been rejected and the index in <code>matrix_intersections</code>
should be
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>,</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>0</mn><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(1, 0, 1, 0)</annotation></semantics></math>.
Since
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>H</mi><mn>1</mn></msub><annotation encoding="application/x-tex">H_1</annotation></semantics></math>
is 1, the corresponding row should be in the top half (rows 1- 7). But
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>H</mi><mn>2</mn></msub><annotation encoding="application/x-tex">H_2</annotation></semantics></math>
is 0 and thus the corresponding row should be in the bottom half within
the top half (rows 5 - 7). Since
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>H</mi><mn>3</mn></msub><annotation encoding="application/x-tex">H_3</annotation></semantics></math>
is 1 and thus the corresponding row should be in the top half (rows 5 -
6). But
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>H</mi><mn>4</mn></msub><annotation encoding="application/x-tex">H_4</annotation></semantics></math>
is 0 and thus the corresponding row should be 6. A useful way to
calculate the row number for an index of XXXX is
<code>2^m - sum(XXXX * 2^(m:1 - 1))</code>. For example for XXXX=1010,
its row number should be
<code>(1 - 1) * 8 + (1 - 0) * 4 + (1 - 1) * 2 + (1 - 0) * 1 + 1 = 16 - 10 = 6</code>.</p>
<p>With the above way of efficiently identifying rows of
<code>weighting_strategy</code>, power simulations could be implemented
as follows:</p>
<ol style="list-style-type: decimal">
<li>Obtain the weighting strategy (once for all simulations)</li>
<li>Simulate a set of p-values</li>
<li>Run the graphical multiple comparison procedure to
<ul>
<li>Determine which hypothesis can be rejected</li>
<li>Remove the rejected hypothesis and identify the row of the weighting
strategy</li>
<li>Repeat until no more hypotheses can be rejected</li>
</ul>
</li>
</ol>
<p>The small modification in Step 3b makes this approach much faster
than the conventional approach for power simulations.</p>
</div>
<div class="section level3">
<h3 id="comparing-different-approaches-to-power-simulations">Comparing different approaches to power simulations<a class="anchor" aria-label="anchor" href="#comparing-different-approaches-to-power-simulations"></a>
</h3>
<p>To benchmark against existing approaches to calculating weighting
strategies, we compare the following approaches:
<code><a href="https://rdrr.io/pkg/gMCP/man/calcPower.html" class="external-link">gMCP::calcPower()</a></code>, Approach 1 (graphicalMCP conventional),
and Approach 2 (graphicalMCP parent-child). Both Holm and fixed sequence
procedures are considered with the numbers of hypotheses of 4, 8, 12,
and 16. Computing time (in median log-10 seconds) is plotted below. We
can see that <code><a href="https://rdrr.io/pkg/gMCP/man/calcPower.html" class="external-link">gMCP::calcPower()</a></code> is the fastest and Approach
1 (graphicalMCP conventional) is the lowest. Note that
<code><a href="https://rdrr.io/pkg/gMCP/man/calcPower.html" class="external-link">gMCP::calcPower()</a></code> implements the simulation using C, which
is known to be faster than R but is not easy to extend to other
situations. Given that the computing time of Approach 2 (graphicalMCP
parent-child) is acceptable, we implement it in
<code><a href="../reference/graph_calculate_power.html">graphicalMCP::graph_calculate_power()</a></code>.</p>
<p><img src="generate-closure_files/figure-html/plot-power-benchmarks-1.png" width="768" style="display: block; margin: auto;"></p>
</div>
</div>
<div class="section level2">
<h2 class="unnumbered" id="reference">Reference<a class="anchor" aria-label="anchor" href="#reference"></a>
</h2>
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0">
<div id="ref-bretz-2011-graphical" class="csl-entry">
Bretz, Frank, Martin Posch, Ekkehard Glimm, Florian Klinglmueller, Willi
Maurer, and Kornelius Rohmeyer. 2011. <span>“Graphical Approaches for
Multiple Comparison Procedures Using Weighted Bonferroni, Simes, or
Parametric Tests.”</span> <em>Biometrical Journal</em> 53 (6): 894–913.
<a href="https://onlinelibrary.wiley.com/doi/10.1002/bimj.201000239" class="external-link">https://onlinelibrary.wiley.com/doi/10.1002/bimj.201000239</a>.
</div>
<div id="ref-lu-2016-graphical" class="csl-entry">
Lu, Kaifeng. 2016. <span>“Graphical Approaches Using a Bonferroni
Mixture of Weighted Simes Tests.”</span> <em>Statistics in Medicine</em>
35 (22): 4041–55. <a href="https://onlinelibrary.wiley.com/doi/10.1002/sim.6985" class="external-link">https://onlinelibrary.wiley.com/doi/10.1002/sim.6985</a>.
</div>
<div id="ref-rohmeyer-2024-gmcp" class="csl-entry">
Rohmeyer, Kornelius, and Florian Klinglmueller. 2024. <em><span class="nocase">gMCP</span>: Graph Based Multiple Test Procedures</em>.
<a href="https://cran.r-project.org/package=gMCP" class="external-link">https://cran.r-project.org/package=gMCP</a>.
</div>
</div>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Dong Xi, Ethan Brockmann, Gilead Sciences, Inc..</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.0.</p>
</div>

    </footer>
</div>





  </body>
</html>
